<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HBnB UML – Documentation Guide</title>
  <link rel="stylesheet" href="styles.css" />
  <meta name="description" content="Article simple qui décrit l'utilité des diagrammes UML demandés pour HBnB Part 1, avec un glossaire rapide.">
</head>
<body>
  <header class="header">
    <div class="container">
      <h1>HBnB UML - Documentation Guide</h1>
      <p class="byline">By Heytem &amp; zaccaria &amp; yassin &amp; guillaume</p>
      <nav class="toc" aria-label="Sommaire">
        <a href="#intro">Introduction</a>
        <a href="#package">Package Diagram</a>
        <a href="#classes">Class Diagram</a>
        <a href="#sequences">Sequence Diagrams</a>
        <a href="#glossary">UML Glossary</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <section id="intro" class="card">
      <h2>Introduction</h2>
      <p>
        Cet article explique l’utilité de chaque diagramme UML demandé dans <strong>HBnB v2 – Part 1</strong>.
        On couvre le <em>Package Diagram</em>, le <em>Class Diagram</em>, les <em>Sequence Diagrams</em>,
        puis un <em>UML Glossary</em> minimal pour les symboles clés.
      </p>
    </section>

    <section id="package" class="card">
      <h2>Package Diagram</h2>
      <p><strong>But :</strong> donner une vue d’ensemble de l’architecture en <em>3 couches</em> et leurs communications.</p>
      <ul>
        <li><strong>Presentation</strong> (API/Services) : reçoit les requêtes, ne contient pas de règles métier.</li>
        <li><strong>Business Logic</strong> (Façade + Services) : orchestre les cas d’usage, applique les règles.</li>
        <li><strong>Persistence</strong> (Repositories/DAO) : accès aux données et au SGBD.</li>
      </ul>
      <p><strong>À montrer :</strong> API → <em>Façade</em> → Services → Repositories → DB. La <em>Façade</em> sert d’interface
        unique entre Présentation et Métier, elle simplifie et isole la complexité.</p>
    </section>

    <section id="classes" class="card">
      <h2>Class Diagram</h2>
      <p><strong>But :</strong> décrire la structure du domaine (classes, attributs, méthodes, relations).</p>
      <ul>
        <li><strong>BaseEntity</strong> : <code>id</code> (UUID4), <code>created_at</code>, <code>updated_at</code>.</li>
        <li><strong>User</strong> (hérite de BaseEntity) : nom, email, <code>is_admin</code>.</li>
        <li><strong>Place</strong> (hérite) : title, description, price, latitude, longitude.</li>
        <li><strong>Amenity</strong> (hérite) : name, description.</li>
        <li><strong>Review</strong> (hérite) : rating (1..5), comment.</li>
      </ul>
      <p><strong>Relations clés :</strong> User 1..* Place (owner), Place *..* Amenity, Place 1..* Review, User 1..* Review.
        Indique les <em>multiplicités</em> (1..*, 0..1…), et l’<em>héritage</em> clair vers BaseEntity.</p>
    </section>

    <section id="sequences" class="card">
      <h2>Sequence Diagrams</h2>
      <p><strong>But :</strong> montrer l’ordre des appels entre couches pour un scénario précis (API → Métier → Données).</p>
      <ol>
        <li><strong>User Registration :</strong> POST /users → Façade → UserService (validation + hash) → UserRepository.save → 201.</li>
        <li><strong>Place Creation :</strong> POST /places → Façade → PlaceService (vérifs) → PlaceRepository.save → 201.</li>
        <li><strong>Review Submission :</strong> POST /places/{id}/reviews → ReviewService (charge Place+User, valide note) → ReviewRepository.save → 201.</li>
        <li><strong>List Places :</strong> GET /places?filters → PlaceService.list → PlaceRepository.query → 200 + liste.</li>
      </ol>
      <p><strong>Astuce :</strong> nomme les lifelines comme tes composants réels pour que le reviewer fasse le lien avec ton code.</p>
    </section>

    <section id="glossary" class="card">
      <h2>UML Glossary</h2>
      <ul class="gloss">
        <li><strong>Association</strong> — lien entre deux classes (ex. Place—Review). Ajouter la multiplicit&eacute; (1..*, 0..1…).</li>
        <li><strong>Agrégation</strong> — losange blanc : “A a des B”, les parties peuvent vivre sans le tout.</li>
        <li><strong>Composition</strong> — losange plein : les parties dépendent du tout (cycle de vie partagé).</li>
        <li><strong>Héritage/Généralisation</strong> — flèche triangle vide vers la super-classe (User → BaseEntity).</li>
        <li><strong>Dépendance</strong> — ligne pointillée : “utilise” (faible couplage) ; ex. Service → Repository.</li>
        <li><strong>Réalisation</strong> — ligne pointillée + triangle : implémentation d’interface / contrat abstrait.</li>
        <li><strong>Multiplicités</strong> — 1..*, 0..1, 1..1 : combien d’instances sont reliées.</li>
        <li><strong>Package</strong> — regroupe classes/composants (idéal pour montrer les couches).</li>
        <li><strong>Façade</strong> — point d’entrée unique vers le métier (simplifie, sécurise, centralise).</li>
      </ul>
    </section>
  </main>

  <footer class="footer">
    <div class="container">
      <small>© 2025 — HBnB UML Blog • Noir sur blanc, simple et lisible.</small>
    </div>
  </footer>
</body>
</html>
